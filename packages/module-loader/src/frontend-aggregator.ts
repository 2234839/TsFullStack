// Frontend aggregation generator implementation
import fs from 'fs-extra';
import { join } from 'path';
import { ModuleInfo, AggregatedOutput } from './types.js';
import { ModuleDiscovery } from './discovery.js';

export class FrontendAggregator {
  private discovery: ModuleDiscovery;

  constructor(discovery: ModuleDiscovery) {
    this.discovery = discovery;
  }

  /** Generate aggregated frontend TypeScript file */
  async generateFrontendAggregation(modules: ModuleInfo[]): Promise<void> {
    const outputDir = this.discovery.getOutputDir();
    fs.ensureDirSync(outputDir);

    const frontendModules = modules.filter(m => m.hasFrontend);
    
    if (frontendModules.length === 0) {
      console.log('No frontend modules found to aggregate');
      return;
    }

    // Generate main frontend aggregation file
    const mainContent = this.generateMainFrontendFile(frontendModules);
    fs.writeFileSync(join(outputDir, 'frontend.ts'), mainContent);
    
    // Generate Vue-specific aggregation file
    const vueContent = this.generateVueAggregationFile(frontendModules);
    fs.writeFileSync(join(outputDir, 'frontend.vue.ts'), vueContent);

    console.log(`Generated frontend aggregation for ${frontendModules.length} modules`);
  }

  /** Generate main frontend aggregation file content */
  private generateMainFrontendFile(modules: ModuleInfo[]): string {
    const imports: string[] = [];
    const reExports: string[] = [];
    
    for (const module of modules) {
      const moduleName = this.getImportName(module.name);
      
      imports.push(`import * as ${moduleName} from '${module.name}/frontend';`);
      reExports.push(`export { ${moduleName} };`);
    }

    return `// Auto-generated by @tsfullstack/module-loader
// This file aggregates all frontend module exports
// DO NOT EDIT MANUALLY

${imports.join('\n')}

// Re-export all modules
${reExports.join('\n')}

// Export all modules as a collection
export const modules = {
${modules.map(m => `  ${this.getImportName(m.name)}: ${this.getImportName(m.name)}`).join(',\n')}
};

// Export module metadata
export const moduleInfo = [
${modules.map(m => `  {
    name: '${m.name}',
    version: '${m.version}',
    path: '${m.path}',
    hasBackend: ${m.hasBackend},
    hasFrontend: ${m.hasFrontend},
    hasVueComponents: ${m.hasVueComponents}
  }`).join(',\n')}
] as const;
`;
  }

  /** Generate Vue-specific aggregation file */
  private generateVueAggregationFile(modules: ModuleInfo[]): string {
    const vueModules = modules.filter(m => m.hasVueComponents);
    
    if (vueModules.length === 0) {
      return `// Auto-generated by @tsfullstack/module-loader
// No Vue components found in modules
// DO NOT EDIT MANUALLY
`;
    }

    const imports: string[] = [];
    const reExports: string[] = [];
    
    for (const module of vueModules) {
      const moduleName = this.getImportName(module.name);
      const importPath = module.path;
      
      imports.push(`import * as ${moduleName} from '${module.name}/frontend/vue';`);
      reExports.push(`export { ${moduleName} };`);
    }

    return `// Auto-generated by @tsfullstack/module-loader
// This file aggregates all Vue component exports from modules
// DO NOT EDIT MANUALLY

${imports.join('\n')}

// Re-export all Vue modules
${reExports.join('\n')}

// Export all Vue modules as a collection
export const vueModules = {
${vueModules.map(m => `  ${this.getImportName(m.name)}: ${this.getImportName(m.name)}`).join(',\n')}
};
`;
  }

  /** Convert module name to valid import name */
  private getImportName(moduleName: string): string {
    // Remove @tsfullstack/ prefix and convert to camelCase
    const baseName = moduleName.replace('@tsfullstack/', '');
    return baseName.split('-').map((word, index) => {
      if (index === 0) return word;
      return word.charAt(0).toUpperCase() + word.slice(1);
    }).join('');
  }
}