// Backend aggregation generator implementation
import fs from 'fs-extra';
import { join } from 'path';
import { ModuleInfo } from './types.js';
import { ModuleDiscovery } from './discovery.js';

export class BackendAggregator {
  private discovery: ModuleDiscovery;

  constructor(discovery: ModuleDiscovery) {
    this.discovery = discovery;
  }

  /** Generate aggregated backend TypeScript file */
  async generateBackendAggregation(modules: ModuleInfo[]): Promise<void> {
    const outputDir = this.discovery.getOutputDir();
    fs.ensureDirSync(outputDir);

    const backendModules = modules.filter(m => m.hasBackend);
    
    if (backendModules.length === 0) {
      console.log('No backend modules found to aggregate');
      return;
    }

    // Generate main backend aggregation file
    const mainContent = this.generateMainBackendFile(backendModules);
    fs.writeFileSync(join(outputDir, 'backend.ts'), mainContent);

    // Generate backend-specific utilities file
    const utilsContent = this.generateBackendUtilsFile(backendModules);
    fs.writeFileSync(join(outputDir, 'backend.utils.ts'), utilsContent);

    console.log(`Generated backend aggregation for ${backendModules.length} modules`);
  }

  /** Generate main backend aggregation file content */
  private generateMainBackendFile(modules: ModuleInfo[]): string {
    const imports: string[] = [];
    const reExports: string[] = [];
    const typeExports: string[] = [];
    
    for (const module of modules) {
      const moduleName = this.getImportName(module.name);
      
      imports.push(`import * as ${moduleName} from '${module.name}/backend';`);
      reExports.push(`export { ${moduleName} };`);
      
      // Add type exports if available
      if (module.hasBackend) {
        typeExports.push(`export type ${moduleName}Types = typeof ${moduleName};`);
      }
    }

    return `// Auto-generated by @tsfullstack/module-loader
// This file aggregates all backend module exports
// DO NOT EDIT MANUALLY

${imports.join('\n')}

// Re-export all modules
${reExports.join('\n')}

// Type exports for all modules
${typeExports.join('\n')}

// Export all modules as a collection
export const modules = {
${modules.map(m => `  ${this.getImportName(m.name)}: ${this.getImportName(m.name)}`).join(',\n')}
};

// Export module metadata
export const moduleInfo = [
${modules.map(m => `  {
    name: '${m.name}',
    version: '${m.version}',
    path: '${m.path}',
    hasBackend: ${m.hasBackend},
    hasFrontend: ${m.hasFrontend},
    hasVueComponents: ${m.hasVueComponents}
  }`).join(',\n')}
] as const;

`;
  }

  /** Generate backend utilities aggregation file */
  private generateBackendUtilsFile(modules: ModuleInfo[]): string {
    const utilsImports: string[] = [];
    const utilsReExports: string[] = [];
    
    for (const module of modules) {
      const moduleName = this.getImportName(module.name);
      
      utilsImports.push(`import { ${moduleName}Utils } from '${module.name}/backend/utils';`);
      utilsReExports.push(`export { ${moduleName}Utils };`);
    }

    return `// Auto-generated by @tsfullstack/module-loader
// This file aggregates all backend utilities from modules
// DO NOT EDIT MANUALLY

${utilsImports.join('\n')}

// Re-export all utilities
${utilsReExports.join('\n')}

// Export all utilities as a collection
export const moduleUtils = {
${modules.map(m => `  ${this.getImportName(m.name)}: ${this.getImportName(m.name)}Utils`).join(',\n')}
};

`;
  }

  /** Convert module name to valid import name */
  private getImportName(moduleName: string): string {
    // Remove @tsfullstack/ prefix and convert to camelCase
    const baseName = moduleName.replace('@tsfullstack/', '');
    return baseName.split('-').map((word, index) => {
      if (index === 0) return word;
      return word.charAt(0).toUpperCase() + word.slice(1);
    }).join('');
  }
}