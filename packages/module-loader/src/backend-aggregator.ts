// Backend aggregation generator implementation
import fs from 'fs-extra';
import { join } from 'path';
import { ModuleInfo } from './types.js';
import { ModuleDiscovery } from './discovery.js';

export class BackendAggregator {
  private discovery: ModuleDiscovery;

  constructor(discovery: ModuleDiscovery) {
    this.discovery = discovery;
  }

  /** Generate aggregated backend TypeScript file */
  async generateBackendAggregation(modules: ModuleInfo[]): Promise<void> {
    const outputDir = 'generated';
    fs.ensureDirSync(outputDir);

    const backendModules = modules.filter(m => m.hasBackend);

    if (backendModules.length === 0) {
      console.log('No backend modules found to aggregate');
      return;
    }

    // Generate main backend aggregation file
    const mainContent = this.generateMainBackendFile(backendModules);
    fs.writeFileSync(join(outputDir, 'backend.ts'), mainContent);

    console.log(`Generated backend aggregation for ${backendModules.length} modules`);
  }

  /** Generate main backend aggregation file content */
  private generateMainBackendFile(modules: ModuleInfo[]): string {
    const imports: string[] = [];
    const reExports: string[] = [];
    const typeExports: string[] = [];

    for (const module of modules) {
      const moduleName = this.getImportName(module.name);

      imports.push(`import { apis as ${moduleName} } from '${module.name}/backend';`);
      reExports.push(`export { ${moduleName} };`);

      // Add type exports if available
      if (module.hasBackend) {
        typeExports.push(`export type ${moduleName}Types = typeof ${moduleName};`);
      }
    }

    return `// Auto-generated by @tsfullstack/module-loader
// This file aggregates all backend module exports
// DO NOT EDIT MANUALLY

${imports.join('\n')}

// Re-export all modules
${reExports.join('\n')}

// Type exports for all modules
${typeExports.join('\n')}

// Export all modules as a collection
export const modules = {
${modules.map(m => `  ${this.getImportName(m.name)}: ${this.getImportName(m.name)}`).join(',\n')}
};

// Export module metadata
export const moduleInfo = [
${modules.map(m => `  {
    name: '${m.name}',
    version: '${m.version}',
    path: '${m.path}',
    hasBackend: ${m.hasBackend},
    hasFrontend: ${m.hasFrontend},
    hasVueComponents: ${m.hasVueComponents}
  }`).join(',\n')}
] as const;

`;
  }

  /** Convert module name to valid import name */
  private getImportName(moduleName: string): string {
    // Remove @tsfullstack/ prefix and convert to camelCase
    const baseName = moduleName.replace('@tsfullstack/', '');
    return baseName.split('-').map((word, index) => {
      if (index === 0) return word;
      return word.charAt(0).toUpperCase() + word.slice(1);
    }).join('');
  }
}